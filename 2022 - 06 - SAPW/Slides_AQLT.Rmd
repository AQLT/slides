---
title: |
 | Trend-cycle extraction and moving average manipulations in R with the rjdfilters package
subtitle: "4th Seasonal Adjustment Practitioners Workshop"
author: "Alain Quartier-la-Tente"
departement: "Insee, LEMNA"
division: |
    | June 8th - June 9th
logo: "img/logobeamer.png"
automaticcontents: false
output:
    beamer_presentation:
        template: template_beamer.tex
        keep_tex: yes
        theme: TorinoTh
        slide_level: 3
        includes:
          in_header: preamble_beamer.tex
themeoptions: "coding=utf8,language=english"
classoption: 'usepdftitle=false,french' #handout
fontsize: 10pt
bibliography: [biblio.bib]
biblio-style: unsrtnat
natbiboptions: [numbers]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = F,
                      fig.align = 'center',
                      fig.path = "img/")
library(knitr)
library(kableExtra)
library(rjdfilters)

is_html <- knitr::is_html_output()
is_latex <- knitr::is_latex_output()

if(is_html){
    fa_arrow_circle_right <- '<i class="fas fa-arrow-circle-right"></i>'
    fa_r_project <- '<i class="fab fa-r-project"></i>'
}else {
    if(is_latex){
        fa_arrow_circle_right <- "\\faIcon{arrow-circle-right}"
        fa_r_project <- "\\faIcon{r-project}"
    }else {
        fa_arrow_circle_right <- "->"
        fa_r_project <- 'R'
    }
}

```

# Introduction

### Introduction

\footnotesize
\highlight{Moving average} are ubiquitous in trend-cycle extraction and seasonal adjustment (e.g. : X-13ARIMA) :
$$
M_\theta(X_t)=\sum_{k=-p}^{+f}\theta_kX_{t+k}
$$

. . .

Applying $M_\theta$ to $X_t=\e^{-i\omega t}$ will have two effects: 
$$
M_{\theta}X_t = \sum_{k=-p}^{+f} \theta_k \e^{-i \omega (t+k)}
= \left(\sum_{k=-p}^{+f} \theta_k \e^{-i \omega k}\right)\cdot X_t = G_\theta(\omega)\e^{-i\Phi_\theta(\omega)} X_t
$$
1. Multiply the level by $G_{\theta}\left(\omega\right)$ (*gain*)  
2. *phase-shift* $\Phi_\theta(\omega)/\omega$ which directly affects the detection of turning points


\begin{figure}[!ht]
\pgfplotsset{width=\textwidth,height=4cm,every axis legend/.append style={font=\footnotesize,
  at={(0.5,-0.1)},
  anchor=north}
    }
\begin{tikzpicture}
\begin{axis}[
xtick={0,3.14159,...,15.70795},
xticklabels={0,$\pi$,$2\pi$,$3\pi$,$4\pi$,$5\pi$} 
]
\addplot[domain=0:5*pi,smooth]    plot (\x,{sin(\x * (pi/2) r)});
\addplot[domain=0:5*pi,smooth, dashed]    
  plot (\x,{1/2*sin(\x* pi/2 r )+1/2*sin((\x -1) * pi/2 r)});
\draw[<->](axis cs: 1.5,1)--(axis cs: 1.5,0.7071068)
  node[pos=0.5, right]{\scriptsize $G_{\theta_0}(\omega)$};
\draw[<->] (axis cs: 3, -0.70710680-0.05)--(axis cs: 3.5,-0.7071068-0.05) 
  node[pos=0.5, below right]{\scriptsize $\Phi_{\theta_0}(\omega)$};
\end{axis}
\end{tikzpicture}
\end{figure}

### Local polynomial filters

Hypothesis : $y_t=\mu_t+\varepsilon_t$ with $\varepsilon_t\overset{i.i.d}{\sim}\mathcal N(0,\sigma^2)$

$\mu_t$ locally approximated by a polynomial of degree $d$:
$$
\forall j\in\left\llbracket -h,h\right\rrbracket : y_{t+j}=m_{t+j}+\varepsilon_{t+j},\quad m_{t+j}=\sum_{i=0}^{d}\beta_{i}j^{i}
$$

. . .

Estimation with WLS ($K$=weights=*kernels*): $\hat{\beta}=(X'KX)^{1}X'Ky$ and
$$
\hat{m}_{t}=\hat\beta_0=w'y=\sum_{j=-h}^{h}w_{j}y_{t-j}
\text{ \faArrowCircleRight{} equivalent to a symmetric moving average}
$$
\faArrowCircleRight{} Arithmetic mean with $K=1$ and $p=0/1$.

\faArrowCircleRight{} Henderson filter with $d=3$ and specific kernel


### What already exists in `r fa_r_project`? (1)

In terms of smoothing, in `r fa_r_project` you can:

1. `stats::filter(., method= "convolution")`: convolution filter
$$
y_t=x_t+f_1y_{i-1}+\dots+f_p y_{i-p}
$$

2. `stats::filter(., method= "recursive", sides = 2)`: symmetric MA ($p$ even)
$$
y_t=f_1x_{t+\lceil (p-1)/2\rceil}+\dots+f_p x_{t+\lceil (p-1)/2\rceil-(p-1)}
$$
or `stats::filter(., method= "recursive", sides = 1)`: real-time asymmetric MA
$$
y_t=f_1x_{t}+\dots+f_p x_{t-(p-1)}
$$
-> possible to add 0 to create general asymmetric filters but endpoints won't be well treated.

### What already exists in `r fa_r_project`? (2)

Local polynomial models ($X=1$ in our case)

3. `KernSmooth::locpoly` local polynomial with gaussian kernel

4. `locfit::locfit` local polynomial with tricube, rectangular, triweight, triangular, epanechnikov, bisquare, gaussian

5. `stats::loess` tricube kernel

. . .

Seasonal adjustment: `seasonal`, `RJdemetra`, `x12`: run X12 but tricky to isolate one MA

. . .

\bigskip 

\faArrowCircleRight{} No way to easily manipulate asymmetric moving averages, analyse their properties (gain, phase-shift)

\faArrowCircleRight{} No way to create SA MA: Henderson, Musgrave, etc.


### `rjdfilters`

`rjdfilters`: \faRProject{} package based on the \large\faJava{} \normalsize libraries of JDemetra+ 3.0

\href{https://github.com/palatej/rjdfilters}{\faGithub{} palatej/rjdfilters}; development version \href{https://github.com/AQLT/rjdfilters}{\faGithub{} AQLT/rjdfilters}

Allows to:

- easily create/combine/apply moving averages `moving_average()`

- study the properties of the MA: plot coef (`plot_coef`), gain (`plot_gain()`), phase-shift (`plot_phase()`) and different statics (`diagnostic_matrix`)

- trend-cycle extraction with different methods to treat endpoints: 

  - `lp_filter` local polynomial filters of Proietti and Luati (2008) (including Musgrave): Henderson, Uniform, biweight, Trapezoidal, Triweight, Tricube, "Gaussian", Triangular, Parabolic (= Epanechnikov)  
  - `rkhs_filter` Reproducing Kernel Hilbert Space (RKHS) of Dagum and Bianconcini (2008) with same kernels  
  - `fst_filter` FST approach of Grun-Rehomme, Guggemos, and Ladiray (2018)  
  - `dfa_filter` derivation of AST approach of Wildi and McElroy (2019)
  
- change the filter used in X-11 for TC extraction

# Moving averages

### Create moving average `moving_average`

```{r}
library(rjdfilters)
m1 = moving_average(rep(1,3), lags = 1); m1 # Forward MA
m2 = moving_average(rep(1,3), lags = -1); m2 # centered MA
m1 + m2; m1*m2; m1 - m2
```

Can be used to create all the MA of X-11:
```{r}
e1 <- moving_average(rep(1,12), lags = -6)
e1 <- e1/sum(e1)
e2 <- moving_average(rep(1/12, 12), lags = -5)
# used to have the 1rst estimate of the trend
tc_1 <- M2X12 <- (e1 + e2)/2
coef(M2X12)
si_1 <- 1 - tc_1
M3 <- moving_average(rep(1/3, 3), lags = -1)
M3X3 <- M3 * M3
# M3X3 moving average applied to each month
M3X3
M3X3_seasonal <- to_seasonal(M3X3, 12)
M3X3_seasonal
s_1 = M3X3_seasonal * si_1
s_1_norm = (1 - M2X12) * s_1
sa_1 <- 1 - s_1_norm
henderson_mm = moving_average(lp_filter(horizon = 6)$filters.coef[, "q=6"], lags = -6)
tc_2 <- henderson_mm * sa_1
si_2 <- 1 - tc_2
M5 <- moving_average(rep(1/5, 5), lags = -2)
M5X5_seasonal <- to_seasonal(M5 * M5, 12)
s_2 = M5X5_seasonal * si_2
s_2_norm = (1 - M2X12) * s_2
sa_2 <- 1 - s_2_norm
tc_f <- henderson_mm * sa_2
```

```{r}
def.par <- par(no.readonly = TRUE)
par(mai = c(0.3, 0.3, 0.2, 0))
layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))

plot_coef(tc_f);plot_coef(sa_2, col = "orange", add = TRUE)
legend("topleft", legend = c("Final TC filter", "Final SA filter"),
       col= c("black", "orange"), lty = 1)

plot_gain(tc_f);plot_gain(sa_2, col = "orange", add = TRUE)

plot_phase(tc_f);plot_phase(sa_2, col = "orange", add = TRUE)
par(def.par)
```

```{r}
y <- retailsa$AllOtherGenMerchandiseStores
trend <- y * tc_1
sa <- y * sa_1
plot(window(ts.union(y, trend, sa), start = 2000),
     plot.type = "single",
      col = c("black","orange", "lightblue"))
```


### lp




### Thank you for your attention {.noframenumbering}

Package \faIcon{r-project}{}:

\href{https://github.com/palatej/rjdfilters}{\faGithub{} palatej/rjdfilters}

Development version \href{https://github.com/AQLT/rjdfilters}{\faGithub{} AQLT/rjdfilters}
